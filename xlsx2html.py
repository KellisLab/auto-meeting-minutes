"""
xlsx2html.py - Convert Excel transcript files to HTML with links and summaries
Usage: python xlsx2html.py input.xlsx video_id [output.html] [--format={simple|numbered}]


This script takes an Excel file generated by txt2xlsx.py and:
1. Creates direct links to video timestamps for all speakers
2. Identifies segments between consecutive timestamps
3. Generates AI-powered summaries for each segment using OpenAI API
4. Places the summaries near their corresponding speaker links
5. Generates separate HTML and Markdown files with:
  - Speaker summaries with direct timestamp links
  - Meeting summaries organized by batch with links to both batch start times and
    individual topic timestamps within each batch
  - Topic-level navigation within meeting summaries


Examples:
python xlsx2html.py meeting.xlsx 757a2c7c-eb52-47d1-9b4a-b2a1014b530b
python xlsx2html.py meeting.xlsx 757a2c7c-eb52-47d1-9b4a-b2a1014b530b meeting_links.html --format=numbered
"""


import sys
import os
import pandas as pd
import argparse
import re
import time
import json
import openai
from dotenv import load_dotenv




# -------------------------------------------------------------
# Constants and Configuration
# -------------------------------------------------------------
# load API KEY from .env
load_dotenv()
# Access the API key
OPENAI_API_KEY = os.getenv("API_KEY")
MODEL = os.getenv("GPT_MODEL")
# Batch size for meeting summaries (in seconds)
BATCH_SIZE_SECONDS = 40 * 60  # 40 minutes in seconds


# -------------------------------------------------------------
# Helper Functions
# -------------------------------------------------------------
def seconds_to_time_str(seconds):
   """
   Convert seconds to H:MM:SS format (e.g., 0:18:52)
   """
   hours, remainder = divmod(int(seconds), 3600)
   minutes, seconds = divmod(remainder, 60)
   return f"{hours}:{minutes:02d}:{seconds:02d}"

def time_str_to_seconds(time_str):
    """
    Convert H:MM:SS time string to seconds
    
    Args:
        time_str (str): Time string in format H:MM:SS
        
    Returns:
        int: Total seconds
    """
    parts = time_str.split(':')
    if len(parts) == 3:
        hours, minutes, seconds = map(int, parts)
        return hours * 3600 + minutes * 60 + seconds
    else:
        # Handle MM:SS format if needed
        return 0  # Return 0 for invalid formats


# -------------------------------------------------------------
# Data Extraction Functions
# -------------------------------------------------------------
def extract_transcript_data(df):
   """
   Extract transcript data from the DataFrame
   """
   transcript_data = []
 
   if 'Name' in df.columns and 'Seconds' in df.columns and 'Text' in df.columns:
       for i, row in df.iterrows():
           if pd.notna(row['Name']) and pd.notna(row['Seconds']) and pd.notna(row['Text']):
               transcript_data.append({
                   'name': row['Name'],
                   'seconds': int(row['Seconds']),
                   'time_str': seconds_to_time_str(row['Seconds']),
                   'text': row['Text']
               })
   else:
       raise ValueError("Excel file doesn't contain the expected columns (Name, Seconds, Text)")
 
   # Sort by timestamp
   transcript_data.sort(key=lambda x: x['seconds'])
   return transcript_data




def extract_unique_speakers(df):
   """
   Extract unique speakers from the DataFrame
   First try using 'First' column for first occurrences only,
   then fallback to using all 'Name' entries
   """
   speaker_data = []
 
   # First, check if we're using the First columns for unique speakers
   if 'First' in df.columns and 'First_Seconds' in df.columns and df['First'].notna().any():
       unique_speakers = df[df['First'].notna()]
       for i, row in unique_speakers.iterrows():
           if pd.notna(row['First']) and pd.notna(row['First_Seconds']):
               speaker_data.append({
                   'name': row['First'],
                   'seconds': int(row['First_Seconds']),
                   'time_str': seconds_to_time_str(row['First_Seconds'])
               })
   # Fallback to using all rows if no "First" column or no data there
   elif 'Name' in df.columns and 'Seconds' in df.columns:
       seen_speakers = set()
       for i, row in df.iterrows():
           if pd.notna(row['Name']) and pd.notna(row['Seconds']):
               if row['Name'] not in seen_speakers:
                   seen_speakers.add(row['Name'])
                   speaker_data.append({
                       'name': row['Name'],
                       'seconds': int(row['Seconds']),
                       'time_str': seconds_to_time_str(row['Seconds'])
                   })
   else:
       raise ValueError("Excel file doesn't contain the expected columns (Name/Seconds or First/First_Seconds)")
 
   # Sort by timestamp
   speaker_data.sort(key=lambda x: x['seconds'])
   return speaker_data




# -------------------------------------------------------------
# Segment Identification and Summarization
# -------------------------------------------------------------
def identify_segments(df):
   """
   Identify segments between consecutive speaker timestamps
   """
   segments = []
 
   # Get all timestamps and speakers
   timestamps = []
 
   # First try 'First'/'First_Seconds' columns
   if 'First' in df.columns and 'First_Seconds' in df.columns and df['First'].notna().any():
       for i, row in df[df['First'].notna()].iterrows():
           if pd.notna(row['First']) and pd.notna(row['First_Seconds']):
               timestamps.append({
                   'name': row['First'],
                   'seconds': int(row['First_Seconds']),
                   'time_str': seconds_to_time_str(row['First_Seconds'])
               })
   # Fallback to all 'Name'/'Seconds' entries
   elif 'Name' in df.columns and 'Seconds' in df.columns:
       for i, row in df.iterrows():
           if pd.notna(row['Name']) and pd.notna(row['Seconds']):
               timestamps.append({
                   'name': row['Name'],
                   'seconds': int(row['Seconds']),
                   'time_str': seconds_to_time_str(row['Seconds'])
               })
 
   # Sort by timestamp
   timestamps.sort(key=lambda x: x['seconds'])
 
   # Create segments between consecutive timestamps
   for i in range(len(timestamps) - 1):
       current = timestamps[i]
       next_ts = timestamps[i + 1]
     
       segment = {
           'speaker': current['name'],
           'start_seconds': current['seconds'],
           'start_time': current['time_str'],
           'end_seconds': next_ts['seconds'],
           'end_time': next_ts['time_str']
       }
     
       segments.append(segment)
 
   # Add the last segment (if available)
   if timestamps:
       last = timestamps[-1]
       # Estimate an end time (e.g., 10 minutes after the last timestamp)
       end_seconds = last['seconds'] + 600
     
       segments.append({
           'speaker': last['name'],
           'start_seconds': last['seconds'],
           'start_time': last['time_str'],
           'end_seconds': end_seconds,
           'end_time': seconds_to_time_str(end_seconds)
       })
 
   return segments




def extract_text_for_segment(transcript_data, start_seconds, end_seconds):
   """
   Extract transcript text for a specific segment
   """
   segment_text = ""
 
   for entry in transcript_data:
       if start_seconds <= entry['seconds'] < end_seconds:
           segment_text += f"{entry['name']}: {entry['text']}\n\n"
 
   return segment_text




# -------------------------------------------------------------
# Topic Extraction and Batch Processing
# -------------------------------------------------------------
def extract_topics_from_summary(summary, video_id=None):
    """
    Extract individual topics from a batch summary.
    Looks for bold titles in the format: **Topic Title - Speaker Name** (H:MM:SS)
    Returns a list of dictionaries with topic, speaker, timestamp, and content info.
    
    Args:
        summary (str): The batch summary text
        video_id (str, optional): Panopto video ID for creating direct links
        
    Returns:
        list: List of topic dictionaries
    """
    import re
    
    # Updated pattern to match: **Topic - Speaker** (H:MM:SS): followed by text
    # This captures the timestamp if present
    pattern = r'\*\*(.+?)\s*-\s*(.+?)\*\*\s*(?:\((\d+:\d{2}:\d{2})\))?\s*:'
    
    # Find all matches in the summary
    topic_matches = list(re.finditer(pattern, summary))
    
    topics = []
    
    for idx, match in enumerate(topic_matches):
        topic = match.group(1).strip()
        # Keep only the first speaker if multiple are present
        speaker_raw = match.group(2).strip()
        speaker = re.split(r'\s*&\s*|,\s*| and ', speaker_raw, maxsplit=1)[0]
        
        # Get timestamp if present
        timestamp = match.group(3)
        timestamp_seconds = None
        video_link = None
        
        # Convert timestamp to seconds if present and video_id is provided
        if timestamp and video_id:
            timestamp_seconds = time_str_to_seconds(timestamp)
            video_link = f'https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={timestamp_seconds}'
        
        start_pos = match.start()
        end_pos = match.end()
        
        # Determine end of content: either next match or end of summary
        next_start = topic_matches[idx + 1].start() if idx + 1 < len(topic_matches) else len(summary)
        
        content = summary[end_pos:next_start].strip()
        
        topics.append({
            'topic': topic,
            'speaker': speaker,
            'timestamp': timestamp,
            'timestamp_seconds': timestamp_seconds,
            'video_link': video_link,
            'position': start_pos,
            'content': content,
            'full_match': match.group(0)
        })
    
    return topics





def create_batches(segments, batch_size_seconds=BATCH_SIZE_SECONDS):
   """
   Create batches of segments that respect speaker boundaries and aim for around 40 minutes each
   """
   batches = []
   current_batch = []
   current_duration = 0
  
   for segment in segments:
       segment_duration = segment['end_seconds'] - segment['start_seconds']
      
       # If adding this segment would exceed batch size AND we already have some segments,
       # finalize the current batch and start a new one
       if current_duration > 0 and current_duration + segment_duration > batch_size_seconds:
           batches.append(current_batch)
           current_batch = []
           current_duration = 0
      
       # Add the segment to the current batch
       current_batch.append(segment)
       current_duration += segment_duration
  
   # Add the last batch if not empty
   if current_batch:
       batches.append(current_batch)
  
   return batches




def extract_text_for_batch(transcript_data, batch_segments):
   """
   Extract transcript text for a batch of segments
   """
   batch_text = ""
  
   # Find the earliest start time and latest end time in the batch
   start_seconds = min(seg['start_seconds'] for seg in batch_segments)
   end_seconds = max(seg['end_seconds'] for seg in batch_segments)
  
   # Extract text for this range
   batch_text = extract_text_for_segment(transcript_data, start_seconds, end_seconds)
  
   return batch_text




# -------------------------------------------------------------
# HTML and Markdown Generation Functions
# -------------------------------------------------------------
def generate_meeting_summaries_html(batches, batch_summaries, video_id, html_file):
    """
    Generate HTML file with meeting batch summaries that include clickable timestamp links
    for both batches and individual topics within each batch
    """
    html_lines = []
    
    html_lines.append('<h1>Meeting Summaries</h1>')
    
    for i, (batch, summary) in enumerate(zip(batches, batch_summaries), 1):
        # Find the start and end times for this batch
        start_seconds = min(segment['start_seconds'] for segment in batch)
        end_seconds = max(segment['end_seconds'] for segment in batch)
        start_time = seconds_to_time_str(start_seconds)
        end_time = seconds_to_time_str(end_seconds)
        
        # Create a link to the video at this timestamp
        video_link = f'https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={start_seconds}'
        
        # Add batch heading with clickable link
        html_lines.append(f'<h2>Batch {i}: <a href="{video_link}">{start_time} - {end_time}</a></h2>')
        
        # Extract topics from the summary with their timestamps
        topics = extract_topics_from_summary(summary, video_id)
        
        if topics:
            # Create a div for all topics in this batch
            html_lines.append('<div class="batch-topics">')
            
            # Process each topic with its direct timestamp link if available
            for topic_info in topics:
                topic = topic_info['topic']
                speaker = topic_info['speaker']
                content = topic_info['content']
                
                # Check if the topic has a direct timestamp link from the summary
                if topic_info['video_link']:
                    # Use the direct link from the timestamp in the summary
                    topic_link = topic_info['video_link']
                    timestamp = topic_info['timestamp']
                    
                    # Add topic as a subheading with direct link from the summary
                    html_lines.append(f'<h3><a href="{topic_link}" class="topic-link">{topic} - {speaker}</a> ({timestamp})</h3>')
                else:
                    # Fallback: Find the segment for this speaker in the batch
                    speaker_segment = None
                    for segment in batch:
                        if segment['speaker'] == speaker:
                            speaker_segment = segment
                            break
                    
                    # If we found the segment, create a link to it
                    if speaker_segment:
                        speaker_seconds = speaker_segment['start_seconds']
                        speaker_time = speaker_segment['start_time']
                        topic_link = f'https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={speaker_seconds}'
                        
                        # Add topic as a subheading with link from segment
                        html_lines.append(f'<h3><a href="{topic_link}" class="topic-link">{topic} - {speaker}</a> ({speaker_time})</h3>')
                    else:
                        # If no segment or timestamp found, just display the topic without a link
                        html_lines.append(f'<h3>{topic} - {speaker}</h3>')
                
                # Add the content for this topic
                html_lines.append(f'<div class="topic-content">{content}</div>')
            
            html_lines.append('</div>') # Close batch-topics div
        else:
            # If no topics were extracted, just show the full summary
            html_lines.append(f'<div class="batch-summary">{summary}</div>')
        
        # Add separator
        html_lines.append('<hr>')
    
    # Combine all lines into HTML
    html_content = '<html>\n<head>\n<title>Meeting Summaries</title>\n'
    html_content += '<style>\n'
    html_content += 'body { font-family: Arial, sans-serif; margin: 20px; }\n'
    html_content += '.batch-summary, .topic-content { margin-bottom: 20px; }\n'
    html_content += 'h2 { color: #333; }\n'
    html_content += 'h3 { color: #555; margin-top: 15px; }\n'
    html_content += 'a { color: #0066cc; }\n'
    html_content += '.topic-link { text-decoration: none; color: #0066cc; }\n'
    html_content += '.topic-link:hover { text-decoration: underline; }\n'
    html_content += '</style>\n</head>\n<body>\n'
    html_content += '\n'.join(html_lines)
    html_content += '\n</body>\n</html>'
    
    # Write the file
    with open(html_file, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    return html_file




def generate_meeting_summaries_markdown(batches, batch_summaries, video_id, md_file):
    """
    Generate Markdown file with meeting batch summaries that include clickable timestamp links
    for both batches and individual topics within each batch
    """
    md_lines = []
    
    md_lines.append('# Meeting Summaries\n')
    
    for i, (batch, summary) in enumerate(zip(batches, batch_summaries), 1):
        # Find the start and end times for this batch
        start_seconds = min(segment['start_seconds'] for segment in batch)
        end_seconds = max(segment['end_seconds'] for segment in batch)
        start_time = seconds_to_time_str(start_seconds)
        end_time = seconds_to_time_str(end_seconds)
        
        # Create a link to the video at this timestamp
        video_link = f'https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={start_seconds}'
        
        # Add batch heading with clickable link
        # md_lines.append(f'## Batch {i}: [{start_time} - {end_time}]({video_link})\n')
        
        # Extract topics from the summary with their timestamps
        topics = extract_topics_from_summary(summary, video_id)
        
        if topics:
            # Process each topic with its direct timestamp link if available
            for topic_info in topics:
                topic = topic_info['topic']
                speaker = topic_info['speaker']
                content = topic_info['content']
                
                # Check if the topic has a direct timestamp link from the summary
                if topic_info['video_link']:
                    # Use the direct link from the timestamp in the summary
                    topic_link = topic_info['video_link']
                    timestamp = topic_info['timestamp']
                    
                    # Add topic as a subheading with direct link from the summary
                    # md_lines.append(f'### {topic} - {speaker} [({timestamp})]({topic_link})')
                    md_lines.append(f'**{topic} - {speaker}** [({timestamp})]({topic_link})')
                else:
                    # Fallback: Find the segment for this speaker in the batch
                    speaker_segment = None
                    for segment in batch:
                        if segment['speaker'] == speaker:
                            speaker_segment = segment
                            break
                    
                    # If we found the segment, create a link to it
                    if speaker_segment:
                        speaker_seconds = speaker_segment['start_seconds']
                        speaker_time = speaker_segment['start_time']
                        topic_link = f'https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={speaker_seconds}'
                        
                        # Add topic as a subheading with link from segment
                        md_lines.append(f'### {topic} - {speaker} [({speaker_time})]({topic_link})')
                    else:
                        # If no segment or timestamp found, just display the topic without a link
                        md_lines.append(f'### {topic} - {speaker}\n')
                
                # Add the content for this topic
                md_lines.append(f'{content}\n')
        else:
            # If no topics were extracted, just show the full summary
            md_lines.append(f'{summary}\n')
    
    # Write the file
    with open(md_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(md_lines))
    
    return md_file




def generate_simple_format(speaker_links, segment_summaries, video_id):
   """Generate HTML in simple format with <br> tags and summaries"""
   html_lines = []
 
   for i, speaker in enumerate(speaker_links):
       name = speaker['name']
       seconds = speaker['seconds']
       time_str = speaker['time_str']
     
       # Create the HTML link
       link = f'<br>{name} (<a href="https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={seconds}">{time_str}</a>)'
       html_lines.append(link)
     
       # Add summary if available
       if i < len(segment_summaries) and 'summary' in segment_summaries[i]:
           html_lines.append(f'<div>{segment_summaries[i]["summary"]}</div>')
 
   return html_lines




def generate_numbered_format(speaker_links, segment_summaries, video_id):
   """Generate HTML in numbered format with line breaks and summaries"""
   html_lines = []
 
   # Add container div
   html_lines.append('<h2>Direct Links:</h2>')
 
   # Generate the numbered list
   for i, speaker in enumerate(speaker_links, 1):
       name = speaker['name']
       seconds = speaker['seconds']
       time_str = speaker['time_str']
     
       # Create the HTML link
       link = f'{i}. {name} (<a href="https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={seconds}">{time_str}</a>)'
       html_lines.append(link)
     
       # Add summary if available (i-1 because speaker_links are 1-indexed but segment_summaries are 0-indexed)
       idx = i-1
       if idx < len(segment_summaries) and 'summary' in segment_summaries[idx]:
           html_lines.append(f'<div>{segment_summaries[idx]["summary"]}</div>')
         
       html_lines.append('<br>')
 
   # Close the div
   html_lines.append('</div>')
 
   return html_lines




def generate_speaker_summary(speaker_links, segment_summaries, video_id):
   """Generate Markdown with speaker summaries and timestamp links"""
   html_lines = []
 
   # Add container div
   html_lines.append('# Speaker Summary')
 
   # Generate the numbered list
   for i, speaker in enumerate(speaker_links, 1):
       name = speaker['name']
       seconds = speaker['seconds']
       time_str = speaker['time_str']
     
       # Create the Markdown link
       link = f'{i}. **{name}** [({time_str})](https://mit.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id={video_id}&start={seconds}) - '
       html_lines.append(link)
      
       # Add summary if available (i-1 because speaker_links are 1-indexed but segment_summaries are 0-indexed)
       idx = i-1
       if idx < len(segment_summaries) and 'summary' in segment_summaries[idx]:
           html_lines.append(f'{segment_summaries[idx]["summary"]}\n')
  
   return html_lines




# -------------------------------------------------------------
# OpenAI Summarization Functions
# -------------------------------------------------------------
def get_api_key():
   """
   Get OpenAI API key from constant, environment variable, or config file
   """
   # Check the constant first
   api_key = OPENAI_API_KEY
 
   # Then try environment variable if constant is empty
   if not api_key:
       api_key = os.environ.get('OPENAI_API_KEY')
 
   # Then check for config file in user's home directory
   if not api_key:
       config_path = os.path.expanduser('~/.openai_config')
       if os.path.exists(config_path):
           try:
               with open(config_path, 'r') as f:
                   config = json.load(f)
                   api_key = config.get('api_key')
           except Exception:
               pass
 
   # If still no API key, prompt user
   if not api_key:
       print("OpenAI API key not found. Please enter your API key:")
       api_key = input("> ").strip()
     
       if api_key:
           # Save for future use (optional)
           try:
               if input("Save API key for future use? (y/n): ").lower() == 'y':
                   os.makedirs(os.path.dirname(config_path), exist_ok=True)
                   with open(config_path, 'w') as f:
                       json.dump({'api_key': api_key}, f)
                   os.chmod(config_path, 0o600)  # Restrict permissions
           except Exception as e:
               print(f"Error saving API key: {e}")
 
   return api_key




def summarize_segment(segment_text, speaker, start_time, end_time, api_key):
   """
   Summarize a segment using OpenAI API
   """
   if not api_key:
       return "API key not provided. Summaries not generated."
 
   if not segment_text.strip():
       return "No text available for summarization."
 
   try:
       openai.api_key = api_key
     
       # Construct prompt
       prompt = (
           "Summarize this meeting notes for the speaker in one paragraph"
           "start with key topic- then summary (no line breaks)"
           "example format: Optimization of UMAP and JSON Communication: Adam Smith presented specific..."
           "Be technical, clear, and precise. Don't hallucinate. "
           "Use bolding, and also use highlighting for the most important words, and for speakers (but not Manolis)\n\n"
           f"MEETING TRANSCRIPT SEGMENT FOR {speaker} ({start_time} - {end_time}):\n\n{segment_text}"
       )
     
       # Using chat completions API
       response = openai.chat.completions.create(
           # recommend 4o instead of 3.5-turbo for better outcome
           model=MODEL,
           messages=[
               {"role": "system", "content": "You are a technical meeting summarizer."},
               {"role": "user", "content": prompt}
           ],
           max_tokens=400,
       )
     
       return response.choices[0].message.content.strip()
 
   except Exception as e:
       return f"Error generating summary: {str(e)}"




def summarize_batch(batch_text, batch_number, start_time, end_time, api_key):
    """
    Summarize a batch of transcript text using OpenAI API, including timestamps in the format (H:MM:SS)
    """
    if not api_key:
        return "API key not provided. Summaries not generated."
    
    if not batch_text.strip():
        return "No text available for summarization."
    
    try:
        openai.api_key = api_key
        
        # Construct prompt for batch summary with explicit timestamp instruction
        prompt = (
            "Summarize in detail the most important ideas of our Mantis All Hands meeting. "
            "Be detailed, thorough, technical, clear, and precise. Don't hallucinate. "
            "Full paragraphs with bolded important words, and bold in-line headers (but no line breaks). "
            "Format must be exactly: **Topic Title - Speaker Name** (H:MM:SS): Content... "
            "Where H:MM:SS is the timestamp in hours:minutes:seconds format (e.g., 0:18:52). "
            # "Make sure to add the timestamp (H:MM:SS) after asterisks of 'Speaker Name**'"
            # "When there's multiple speakers for one topic, just list one. "
            "The timestamp is crucial as it will be used to generate direct video links. "
            "Explain each key idea in depth, and don't leave out any details, but don't make up stuff either. "
            "Keep all the content, and nothing but the content, for each key idea. "
            "For each idea, also describe the students involved in the discussion. "
            "After summarizing the topics, DO NOT end with overall summarizing sentence or paragraph. "
            f"MEETING TRANSCRIPT BATCH #{batch_number} ({start_time} - {end_time}):\n\n{batch_text}"
        )
        
        # Using chat completions API
        response = openai.chat.completions.create(
            model=MODEL,
            messages=[
                {"role": "system", "content": "You are a technical meeting summarizer."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=10000,  # More tokens for batch summaries
        )
        
        return response.choices[0].message.content.strip()
    
    except Exception as e:
        return f"Error generating batch summary: {str(e)}"



# -------------------------------------------------------------
# Main Processing Functions
# -------------------------------------------------------------
def process_xlsx(xlsx_file, video_id, html_file=None, format_type='simple', summary_file=None,
               speaker_summary_file=None, meeting_summary_md_file=None):
   """
   Process Excel file to generate HTML links with summaries and meeting summaries
  
   Args:
       xlsx_file (str): Path to input Excel file
       video_id (str): Panopto video ID
       html_file (str, optional): Path to output HTML file for speaker links
       format_type (str, optional): Format type ('simple' or 'numbered')
       summary_file (str, optional): Path to output HTML file for meeting summaries
       speaker_summary_file (str, optional): Path to output Markdown file for speaker summaries
       meeting_summary_md_file (str, optional): Path to output Markdown file for meeting summaries
      
   Returns:
       tuple: Paths to the generated files (html_file, summary_file, speaker_summary_file, meeting_summary_md_file)
   """
   if html_file is None:
       html_file = os.path.splitext(xlsx_file)[0] + '_speaker_summaries.html'


   if speaker_summary_file is None:
       speaker_summary_file = os.path.splitext(xlsx_file)[0] + '_speaker_summaries.md'
  
   if summary_file is None:
       summary_file = os.path.splitext(xlsx_file)[0] + '_meeting_summaries.html'
  
   if meeting_summary_md_file is None:
       meeting_summary_md_file = os.path.splitext(xlsx_file)[0] + '_meeting_summaries.md'
 
   # Ensure video_id is provided
   if not video_id:
       raise ValueError("Panopto video ID is required")
 
   # Get OpenAI API key
   api_key = get_api_key()
   if not api_key:
       print("Warning: OpenAI API key not provided. Summaries will not be generated.")
       return None, None, None, None
 
   try:
       # Read the Excel file
       df = pd.read_excel(xlsx_file)
     
       # Extract speaker links
       speaker_links = extract_unique_speakers(df)
     
       # Extract full transcript data
       transcript_data = extract_transcript_data(df)
     
       # Identify segments between consecutive timestamps
       segments = identify_segments(df)
     
       # Generate summaries for each segment
       print(f"Generating summaries for {len(segments)} segments...")
       for i, segment in enumerate(segments):
           print(f"Processing segment {i+1}/{len(segments)}: {segment['speaker']} ({segment['start_time']} - {segment['end_time']})")
         
           # Extract text for this segment
           segment_text = extract_text_for_segment(
               transcript_data,
               segment['start_seconds'],
               segment['end_seconds']
           )
         
           # Generate summary
           segment['summary'] = summarize_segment(
               segment_text,
               segment['speaker'],
               segment['start_time'],
               segment['end_time'],
               api_key
           )
      
       # Generate original HTML output
       if format_type.lower() == 'numbered':
           html_lines = generate_numbered_format(speaker_links, segments, video_id)
       else:  # simple format
           html_lines = generate_simple_format(speaker_links, segments, video_id)
     
       # Write the HTML file
       with open(html_file, 'w', encoding='utf-8') as f:
           f.write('\n'.join(html_lines))
      
       # Generate speaker summary markdown
       speaker_summary_lines = generate_speaker_summary(speaker_links, segments, video_id)


       # Write the speaker summary md file
       with open(speaker_summary_file, 'w', encoding='utf-8') as f:
           f.write('\n'.join(speaker_summary_lines))


       print(f"Generated speaker summary markdown: {speaker_summary_file}")
       print(f"Generated HTML with links and summaries: {html_file}")
      
       # Create batches for meeting summaries
       print("Creating batches for meeting summaries...")
       batches = create_batches(segments)
       print(f"Created {len(batches)} batches")
      
       # Generate batch summaries
       batch_summaries = []
       for i, batch in enumerate(batches, 1):
           # Find start and end times for this batch
           start_seconds = min(segment['start_seconds'] for segment in batch)
           end_seconds = max(segment['end_seconds'] for segment in batch)
           start_time = seconds_to_time_str(start_seconds)
           end_time = seconds_to_time_str(end_seconds)
          
           print(f"Processing batch {i}/{len(batches)}: {start_time} - {end_time}")
          
           # Extract text for this batch
           batch_text = extract_text_for_batch(transcript_data, batch)
          
           # Generate summary
           summary = summarize_batch(
               batch_text,
               i,
               start_time,
               end_time,
               api_key
           )
          
           batch_summaries.append(summary)
      
       # Generate meeting summaries HTML with topic-level clickable links
       generate_meeting_summaries_html(batches, batch_summaries, video_id, summary_file)
       print(f"Generated meeting summaries HTML: {summary_file}")
      
       # Generate meeting summaries Markdown with topic-level clickable links
       generate_meeting_summaries_markdown(batches, batch_summaries, video_id, meeting_summary_md_file)
       print(f"Generated meeting summaries Markdown: {meeting_summary_md_file}")
     
       return html_file, summary_file, speaker_summary_file, meeting_summary_md_file
     
   except Exception as e:
       print(f"Error processing Excel file: {e}", file=sys.stderr)
       raise


def main():
   """
   Main function to handle command-line arguments and process Excel file.
   """
   # Set up argument parser
   parser = argparse.ArgumentParser(description='Convert Excel transcript to HTML links with summaries')
   parser.add_argument('input_file', help='Input Excel file')
   parser.add_argument('video_id', help='Panopto video ID (required)')
   parser.add_argument('output_file', nargs='?', help='Output HTML file (optional)')
   parser.add_argument('--format', choices=['simple', 'numbered'], default='numbered',
                     help='Output format: simple or numbered (default: numbered)')
   parser.add_argument('--summary-file', help='Output file for meeting summaries HTML (optional)')
   parser.add_argument('--speaker-summary-file', help='Output file for speaker summaries markdown (optional)')
   parser.add_argument('--meeting-summary-md-file', help='Output file for meeting summaries markdown (optional)')
 
   args = parser.parse_args()
 
   try:
       html_file, summary_html_file, speaker_summary_file, meeting_summary_md_file = process_xlsx(
           args.input_file,
           args.video_id,
           args.output_file,
           args.format,
           args.summary_file,
           args.speaker_summary_file,
           args.meeting_summary_md_file
       )
     
       if html_file and summary_html_file:
           print(f"Processing complete!")
           print(f"Speaker links HTML: {html_file}")
           print(f"Speaker summary Markdown: {speaker_summary_file}")
           print(f"Meeting summaries HTML: {summary_html_file}")
           print(f"Meeting summaries Markdown: {meeting_summary_md_file}")
     
   except Exception as e:
       print(f"Error: {e}", file=sys.stderr)
       sys.exit(1)




if __name__ == "__main__":
   main()#!/usr/bin/env python3

